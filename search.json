[
  {
    "objectID": "project5.html",
    "href": "project5.html",
    "title": "Proyecto 5",
    "section": "",
    "text": "Proyecto 5\nInformaci√≥n sobre el Proyecto 5. Puedes expandir esta p√°gina con subsecciones."
  },
  {
    "objectID": "project3.html",
    "href": "project3.html",
    "title": "Proyecto 3",
    "section": "",
    "text": "Proyecto 3\nDetalles del Proyecto 3. Puedes a√±adir im√°genes, gr√°ficos o texto adicional."
  },
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "Proyecto 1",
    "section": "",
    "text": "En la era digital actual, el big data ha emergido como un recurso valioso para las organizaciones, permiti√©ndoles extraer, procesar y analizar datos significativos. El big data se caracteriza por sus cuatro V: volumen, velocidad, variedad y veracidad. El volumen se refiere a la gran cantidad de datos generados y almacenados; la velocidad, a la rapidez con la que se generan y procesan; la variedad, a los diferentes tipos de datos (estructurados y no estructurados); y la veracidad, a la calidad y precisi√≥n de dichos datos. La capacidad de manejar y analizar estos grandes vol√∫menes de informaci√≥n de manera eficiente es crucial para aprovechar al m√°ximo el potencial del big data (M√ºller et al., 2016).\nEl an√°lisis de big data permite a las organizaciones identificar patrones, predecir tendencias y optimizar procesos, lo que puede resultar en mejoras significativas en la eficiencia operativa y en la toma de decisiones estrat√©gicas. Sin embargo, la manipulaci√≥n de grandes vol√∫menes de datos presenta desaf√≠os importantes en t√©rminos de infraestructura, almacenamiento, procesamiento y an√°lisis. Los algoritmos eficientes son fundamentales para enfrentar estos desaf√≠os y garantizar que los sistemas de big data funcionen de manera √≥ptima (Manyika et al., 2011).\nEste reporte se enfoca en comparar diferentes √≥rdenes de crecimiento mediante simulaciones en un entorno de Jupyter. Se analizar√°n los siguientes casos: \\(O(1)\\) vs \\(O(\\log n)\\), \\(O(n)\\) vs \\(O(n \\log n)\\), \\(O(n^2)\\) vs \\(O(n^3)\\), \\(O(a^n)\\) vs \\(O(n!)\\) y \\(O(n!)\\) vs \\(O(n^n)\\). Para cada comparaci√≥n, se seleccionar√°n rangos adecuados de \\(n\\) que permitan visualizar claramente las diferencias entre estos √≥rdenes. Se generar√°n gr√°ficas para cada caso y se discutir√°n las observaciones correspondientes. Adem√°s, se incluir√° una tabla con tiempos de ejecuci√≥n simulados para algoritmos ficticios asociados a los √≥rdenes de crecimiento mencionados, utilizando distintos tama√±os de entrada \\(n\\). Este an√°lisis proporciona una visi√≥n clara de c√≥mo los diferentes √≥rdenes de crecimiento afectan el rendimiento y la eficiencia de los algoritmos.\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport math\nimport matplotlib.pyplot as plt\n\n\n\ndef constant(n): return 1\ndef logarithmic(n): return np.log(n)\ndef linear(n): return n\ndef linear_logarithmic(n): return n * np.log(n)\ndef quadratic(n): return n**2\ndef cubic(n): return n**3\ndef exponential(n, a=2): return a**n\ndef factorial(n): return math.factorial(n)\ndef double_exponential(n): return n**n\n\n\n\ndef plot_comparison(funcs, labels, title, x_range):\n    plt.figure(figsize=(7, 5))\n    for func, label in zip(funcs, labels):\n        plt.plot(x_range, [func(x) / 1e9 for x in x_range], label=label)\n    plt.xlabel('n')\n    plt.ylabel('Tiempo (s)')\n    plt.title(title)\n    plt.legend()\n    plt.yscale('log')\n    plt.xscale('log')\n    plt.grid(True)\n    plt.show()\n\n\n\nx_range_small = np.arange(1, 10)\nx_range_medium = np.arange(1, 100)\n\n# Comparaci√≥n 1: O(1) vs O(log n)\nplot_comparison([constant, logarithmic], ['O(1)', 'O(log n)'], 'Figura 1 - Comparaci√≥n de O(1) con O(log n)', x_range_small)\n\n# Comparaci√≥n 2: O(n) vs O(n log n)\nplot_comparison([linear, linear_logarithmic], ['O(n)', 'O(n log n)'], 'Figura 2 - Comparaci√≥n de O(n) con O(n log n)', x_range_medium)\n\n# Comparaci√≥n 3: O(n^2) vs O(n^3)\nplot_comparison([quadratic, cubic], ['O(n^2)', 'O(n^3)'], 'Figura 3 - Comparaci√≥n de O(n^2) con O(n^3)', x_range_medium)\n\n# Comparaci√≥n 4: O(2^n) vs O(n!)\nplot_comparison([lambda n: exponential(n, 2), factorial], ['O(2^n)', 'O(n!)'], 'Figura 4 - Comparaci√≥n de O(2^n) con O(n!)', x_range_small)\n\n# Comparaci√≥n 5: O(n!) vs O(n^n)\nplot_comparison([factorial, double_exponential], ['O(n!)', 'O(n^n)'], 'Figura 5 - Comparaci√≥n de O(n!) con O(n^n)', x_range_small)\n\n\n\nNota: Se cre√≥ una tabla con tiempos de ejecuci√≥n simulados para algoritmos ficticios con los √≥rdenes de crecimiento mencionados.\n# Tama√±os de entrada\nn_values = [100, 1000, 10000, 100000]\n\n# Funciones de costo\ncost_functions = {\n    'O(1)': constant,\n    'O(log n)': logarithmic,\n    'O(n)': linear,\n    'O(n log n)': linear_logarithmic,\n    'O(n^2)': quadratic,\n    'O(n^3)': cubic,\n    'O(2^n)': lambda n: exponential(n, 2),\n    'O(n!)': factorial,\n    'O(n^n)': double_exponential\n}\n\n# Elaboraci√≥n de la tabla\nresults = []\nfor n in n_values:\n    row = {'n': n}\n    for label, func in cost_functions.items():\n        try:\n            row[label] = func(n) / 1e9  # Conversi√≥n a segundos\n        except OverflowError:\n            row[label] = 'Overflow'\n    results.append(row)\n\nimport pandas as pd\ndf = pd.DataFrame(results)\ndf.set_index('n', inplace=True)\ndf\n\n\n\n\n\n\n\n\n\nasd\n\n\n\nsda\n\n\n\nsd\n\n\n\nasd\n\n\n\nasd\n\n\n\n\n\nA continuaci√≥n se presenta una tabla comparativa de los tiempos simulados para diferentes √≥rdenes de crecimiento, utilizando distintos tama√±os de entrada \\(n\\). Los resultados se expresan en segundos. En algunos casos, se muestra ‚ÄúOverflow‚Äù cuando el valor resultante excede los l√≠mites de representaci√≥n.\nTabla 1. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(1), O(log n), O(n), O(n log n), O(n¬≤)\n\n\n\n\n\n\n\n\n\n\n\nn\nO(1)\nO(log n)\nO(n)\nO(n log n)\nO(n¬≤)\n\n\n\n\n100\n1.00e-09\n4.61e-09\n1.00e-07\n4.61e-07\n1.00e-05\n\n\n1000\n1.00e-09\n6.91e-09\n1.00e-06\n6.91e-06\n1.00e-03\n\n\n10000\n1.00e-09\n9.21e-09\n1.00e-05\n9.21e-05\n1.00e-01\n\n\n100000\n1.00e-09\n1.15e-08\n1.00e-04\n1.15e-03\n1.00e+01\n\n\n\nTabla 2. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(n¬≥), O(2‚Åø)\n\n\n\nn\nO(n¬≥)\nO(2‚Åø)\n\n\n\n\n100\n1.00e-03\n1.27e+21\n\n\n1000\n1.00e+00\nOverflow\n\n\n10000\n1.00e+03\nOverflow\n\n\n100000\n1.00e+06\nOverflow\n\n\n\nTabla 3. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(n!), O(n‚Åø)\n\n\n\nn\nO(n!)\nO(n‚Åø)\n\n\n\n\n100\nOverflow\nOverflow\n\n\n1000\nOverflow\nOverflow\n\n\n10000\nOverflow\nOverflow\n\n\n100000\nOverflow\nOverflow\n\n\n\n\nNota: Algunos valores como O(2‚Åø), O(n!) y O(n‚Åø) para valores grandes de \\(n\\) generan cantidades inmanejables por el sistema, resultando en Overflow. Esto refleja la inviabilidad pr√°ctica de algoritmos con estas complejidades cuando se trabaja con grandes vol√∫menes de datos.\n\nComo se muestra en la tabla, el tiempo de ejecuci√≥n de O(1) no depende del tama√±o de n.¬†Este mantiene un mismo valor, lo que indica que su tiempo de ejecuci√≥n es constante. Por otro lado, los valores de O(log n) aumentan lentamente a medida que n crece, lo cual es consistente con su comportamiento logar√≠tmico. En el caso de O(n), los valores aumentan de forma lineal conforme n se incrementa. Los valores de O(n log n) aumentan m√°s r√°pido que los de O(n), pero no tan aceleradamente como los de O(n¬≤). Por su parte, O(n¬≤) crece r√°pidamente a medida que n aumenta, y O(n¬≥) lo hace de forma a√∫n m√°s acelerada, incluso con valores peque√±os de entrada.\nDurante la ejecuci√≥n del c√≥digo, algunos resultados aparecen como ‚ÄúOverflow‚Äù. Esto se debe a que las funciones O(2‚Åø), O(n!) y O(n‚Åø) para valores grandes de n (como 10,000 o 100,000) generan n√∫meros extremadamente grandes, lo que excede la capacidad de representaci√≥n y manejo num√©rico en Python.\n\n\n\n\nLa manipulaci√≥n de grandes vol√∫menes de informaci√≥n presenta importantes desaf√≠os debido a los costos de c√≥mputo. Estos costos se relacionan con el gasto monetario, los recursos computacionales requeridos, el tiempo de procesamiento, el uso de memoria, el almacenamiento y el consumo energ√©tico. A continuaci√≥n se presentan algunas de las implicaciones m√°s relevantes:\n\nInfraestructura: Manipular grandes vol√∫menes de datos requiere una infraestructura robusta, que incluye servidores potentes, almacenamiento masivo y redes de alta velocidad. Esto representa costos elevados en hardware, mantenimiento y consumo energ√©tico (Armbrust et al., 2010).\nEnerg√≠a: Los centros de datos que procesan grandes cantidades de informaci√≥n consumen enormes cantidades de energ√≠a, lo cual incrementa los costos operativos y contribuye al impacto ambiental debido a las emisiones de carbono (Baliga et al., 2011).\nAlmacenamiento: El almacenamiento de grandes vol√∫menes de datos requiere soluciones escalables y eficientes. Este aspecto representa un costo considerable, ya que tambi√©n debe garantizarse la recuperaci√≥n oportuna de la informaci√≥n.\nProcesamiento: Procesar datos en tiempo real o en tiempo cercano al real implica el uso de algoritmos eficientes y de recursos de c√≥mputo significativos. Estos costos pueden incrementarse especialmente al utilizar tecnolog√≠as como el aprendizaje autom√°tico y la inteligencia artificial (Wang et al., 2015).\n\nEn conjunto, la gesti√≥n de grandes vol√∫menes de informaci√≥n conlleva costos considerables en t√©rminos de infraestructura, energ√≠a, almacenamiento, procesamiento, seguridad y mantenimiento. Estos aspectos deben ser cuidadosamente planeados y gestionados para asegurar soluciones de big data eficientes y sostenibles.\n\n\n\n\nEn las simulaciones realizadas se observ√≥ que los √≥rdenes de crecimiento m√°s bajos, como O(1), O(log n) y O(n), resultan altamente eficientes. Son ideales para tareas que demandan rendimiento √≥ptimo y tiempos de respuesta reducidos.\nPor otro lado, los √≥rdenes de crecimiento O(n log n) y O(n¬≤) demostraron ser pr√°cticas y ampliamente aplicables, al ofrecer un buen equilibrio entre eficiencia y capacidad de procesamiento.\nEn contraste, las funciones con √≥rdenes de crecimiento elevados como O(2‚Åø), O(n!) y O(n‚Åø) resultaron ineficientes, generando tiempos de ejecuci√≥n excesivos o incluso errores de memoria.\nLa tabla de tiempos de ejecuci√≥n simulados confirma c√≥mo el crecimiento del orden afecta directamente el rendimiento de los algoritmos. A mayor orden, mayor consumo de recursos y tiempo; a menor orden, mayor eficiencia en la ejecuci√≥n.\n\n\n\n\nM√ºller, V. C., Schal, J. M., Meyer-Lindenberg, A. (2016). Machine Learning for Brain Imaging. Cambridge University Press.\nManyika, J., Chui, M., Brown, B., Bughin, J., Dobbs, R., Roxburgh, C., & Byers, A. H. (2011). Big data: The next frontier for innovation, competition, and productivity. McKinsey Global Institute. https://www.mckinsey.com/business-functions/mckinsey-analytics/our-insights/big-data-the-next-frontier-for-innovation\nArmbrust, M., Fox, A., Griffith, R., Joseph, A. D., Katz, R. H., Konwinski, A., et al.¬†(2010). A View of Cloud Computing. Communications of the ACM, 53(4), 50‚Äì58. https://doi.org/10.1145/1721654.1721672\nBaliga, J., Ayre, R., Hinton, K., & Tucker, R. S. (2011). Energy-Efficient Telecommunications.\nWang, L., Chen, Y., & Liu, Q. (2015). Big Data Processing: A Survey. Springer."
  },
  {
    "objectID": "project1.html#introducci√≥n",
    "href": "project1.html#introducci√≥n",
    "title": "Proyecto 1",
    "section": "",
    "text": "En la era digital actual, el big data ha emergido como un recurso valioso para las organizaciones, permiti√©ndoles extraer, procesar y analizar datos significativos. El big data se caracteriza por sus cuatro V: volumen, velocidad, variedad y veracidad. El volumen se refiere a la gran cantidad de datos generados y almacenados; la velocidad, a la rapidez con la que se generan y procesan; la variedad, a los diferentes tipos de datos (estructurados y no estructurados); y la veracidad, a la calidad y precisi√≥n de dichos datos. La capacidad de manejar y analizar estos grandes vol√∫menes de informaci√≥n de manera eficiente es crucial para aprovechar al m√°ximo el potencial del big data (M√ºller et al., 2016).\nEl an√°lisis de big data permite a las organizaciones identificar patrones, predecir tendencias y optimizar procesos, lo que puede resultar en mejoras significativas en la eficiencia operativa y en la toma de decisiones estrat√©gicas. Sin embargo, la manipulaci√≥n de grandes vol√∫menes de datos presenta desaf√≠os importantes en t√©rminos de infraestructura, almacenamiento, procesamiento y an√°lisis. Los algoritmos eficientes son fundamentales para enfrentar estos desaf√≠os y garantizar que los sistemas de big data funcionen de manera √≥ptima (Manyika et al., 2011).\nEste reporte se enfoca en comparar diferentes √≥rdenes de crecimiento mediante simulaciones en un entorno de Jupyter. Se analizar√°n los siguientes casos: \\(O(1)\\) vs \\(O(\\log n)\\), \\(O(n)\\) vs \\(O(n \\log n)\\), \\(O(n^2)\\) vs \\(O(n^3)\\), \\(O(a^n)\\) vs \\(O(n!)\\) y \\(O(n!)\\) vs \\(O(n^n)\\). Para cada comparaci√≥n, se seleccionar√°n rangos adecuados de \\(n\\) que permitan visualizar claramente las diferencias entre estos √≥rdenes. Se generar√°n gr√°ficas para cada caso y se discutir√°n las observaciones correspondientes. Adem√°s, se incluir√° una tabla con tiempos de ejecuci√≥n simulados para algoritmos ficticios asociados a los √≥rdenes de crecimiento mencionados, utilizando distintos tama√±os de entrada \\(n\\). Este an√°lisis proporciona una visi√≥n clara de c√≥mo los diferentes √≥rdenes de crecimiento afectan el rendimiento y la eficiencia de los algoritmos."
  },
  {
    "objectID": "project1.html#desarrollo",
    "href": "project1.html#desarrollo",
    "title": "Proyecto 1",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport math\nimport matplotlib.pyplot as plt\n\n\n\ndef constant(n): return 1\ndef logarithmic(n): return np.log(n)\ndef linear(n): return n\ndef linear_logarithmic(n): return n * np.log(n)\ndef quadratic(n): return n**2\ndef cubic(n): return n**3\ndef exponential(n, a=2): return a**n\ndef factorial(n): return math.factorial(n)\ndef double_exponential(n): return n**n\n\n\n\ndef plot_comparison(funcs, labels, title, x_range):\n    plt.figure(figsize=(7, 5))\n    for func, label in zip(funcs, labels):\n        plt.plot(x_range, [func(x) / 1e9 for x in x_range], label=label)\n    plt.xlabel('n')\n    plt.ylabel('Tiempo (s)')\n    plt.title(title)\n    plt.legend()\n    plt.yscale('log')\n    plt.xscale('log')\n    plt.grid(True)\n    plt.show()\n\n\n\nx_range_small = np.arange(1, 10)\nx_range_medium = np.arange(1, 100)\n\n# Comparaci√≥n 1: O(1) vs O(log n)\nplot_comparison([constant, logarithmic], ['O(1)', 'O(log n)'], 'Figura 1 - Comparaci√≥n de O(1) con O(log n)', x_range_small)\n\n# Comparaci√≥n 2: O(n) vs O(n log n)\nplot_comparison([linear, linear_logarithmic], ['O(n)', 'O(n log n)'], 'Figura 2 - Comparaci√≥n de O(n) con O(n log n)', x_range_medium)\n\n# Comparaci√≥n 3: O(n^2) vs O(n^3)\nplot_comparison([quadratic, cubic], ['O(n^2)', 'O(n^3)'], 'Figura 3 - Comparaci√≥n de O(n^2) con O(n^3)', x_range_medium)\n\n# Comparaci√≥n 4: O(2^n) vs O(n!)\nplot_comparison([lambda n: exponential(n, 2), factorial], ['O(2^n)', 'O(n!)'], 'Figura 4 - Comparaci√≥n de O(2^n) con O(n!)', x_range_small)\n\n# Comparaci√≥n 5: O(n!) vs O(n^n)\nplot_comparison([factorial, double_exponential], ['O(n!)', 'O(n^n)'], 'Figura 5 - Comparaci√≥n de O(n!) con O(n^n)', x_range_small)\n\n\n\nNota: Se cre√≥ una tabla con tiempos de ejecuci√≥n simulados para algoritmos ficticios con los √≥rdenes de crecimiento mencionados.\n# Tama√±os de entrada\nn_values = [100, 1000, 10000, 100000]\n\n# Funciones de costo\ncost_functions = {\n    'O(1)': constant,\n    'O(log n)': logarithmic,\n    'O(n)': linear,\n    'O(n log n)': linear_logarithmic,\n    'O(n^2)': quadratic,\n    'O(n^3)': cubic,\n    'O(2^n)': lambda n: exponential(n, 2),\n    'O(n!)': factorial,\n    'O(n^n)': double_exponential\n}\n\n# Elaboraci√≥n de la tabla\nresults = []\nfor n in n_values:\n    row = {'n': n}\n    for label, func in cost_functions.items():\n        try:\n            row[label] = func(n) / 1e9  # Conversi√≥n a segundos\n        except OverflowError:\n            row[label] = 'Overflow'\n    results.append(row)\n\nimport pandas as pd\ndf = pd.DataFrame(results)\ndf.set_index('n', inplace=True)\ndf"
  },
  {
    "objectID": "project1.html#an√°lisis-de-resultados",
    "href": "project1.html#an√°lisis-de-resultados",
    "title": "Proyecto 1",
    "section": "",
    "text": "asd\n\n\n\nsda\n\n\n\nsd\n\n\n\nasd\n\n\n\nasd\n\n\n\n\n\nA continuaci√≥n se presenta una tabla comparativa de los tiempos simulados para diferentes √≥rdenes de crecimiento, utilizando distintos tama√±os de entrada \\(n\\). Los resultados se expresan en segundos. En algunos casos, se muestra ‚ÄúOverflow‚Äù cuando el valor resultante excede los l√≠mites de representaci√≥n.\nTabla 1. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(1), O(log n), O(n), O(n log n), O(n¬≤)\n\n\n\n\n\n\n\n\n\n\n\nn\nO(1)\nO(log n)\nO(n)\nO(n log n)\nO(n¬≤)\n\n\n\n\n100\n1.00e-09\n4.61e-09\n1.00e-07\n4.61e-07\n1.00e-05\n\n\n1000\n1.00e-09\n6.91e-09\n1.00e-06\n6.91e-06\n1.00e-03\n\n\n10000\n1.00e-09\n9.21e-09\n1.00e-05\n9.21e-05\n1.00e-01\n\n\n100000\n1.00e-09\n1.15e-08\n1.00e-04\n1.15e-03\n1.00e+01\n\n\n\nTabla 2. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(n¬≥), O(2‚Åø)\n\n\n\nn\nO(n¬≥)\nO(2‚Åø)\n\n\n\n\n100\n1.00e-03\n1.27e+21\n\n\n1000\n1.00e+00\nOverflow\n\n\n10000\n1.00e+03\nOverflow\n\n\n100000\n1.00e+06\nOverflow\n\n\n\nTabla 3. Tiempos simulados para diferentes √≥rdenes de crecimiento de O(n!), O(n‚Åø)\n\n\n\nn\nO(n!)\nO(n‚Åø)\n\n\n\n\n100\nOverflow\nOverflow\n\n\n1000\nOverflow\nOverflow\n\n\n10000\nOverflow\nOverflow\n\n\n100000\nOverflow\nOverflow\n\n\n\n\nNota: Algunos valores como O(2‚Åø), O(n!) y O(n‚Åø) para valores grandes de \\(n\\) generan cantidades inmanejables por el sistema, resultando en Overflow. Esto refleja la inviabilidad pr√°ctica de algoritmos con estas complejidades cuando se trabaja con grandes vol√∫menes de datos.\n\nComo se muestra en la tabla, el tiempo de ejecuci√≥n de O(1) no depende del tama√±o de n.¬†Este mantiene un mismo valor, lo que indica que su tiempo de ejecuci√≥n es constante. Por otro lado, los valores de O(log n) aumentan lentamente a medida que n crece, lo cual es consistente con su comportamiento logar√≠tmico. En el caso de O(n), los valores aumentan de forma lineal conforme n se incrementa. Los valores de O(n log n) aumentan m√°s r√°pido que los de O(n), pero no tan aceleradamente como los de O(n¬≤). Por su parte, O(n¬≤) crece r√°pidamente a medida que n aumenta, y O(n¬≥) lo hace de forma a√∫n m√°s acelerada, incluso con valores peque√±os de entrada.\nDurante la ejecuci√≥n del c√≥digo, algunos resultados aparecen como ‚ÄúOverflow‚Äù. Esto se debe a que las funciones O(2‚Åø), O(n!) y O(n‚Åø) para valores grandes de n (como 10,000 o 100,000) generan n√∫meros extremadamente grandes, lo que excede la capacidad de representaci√≥n y manejo num√©rico en Python.\n\n\n\n\nLa manipulaci√≥n de grandes vol√∫menes de informaci√≥n presenta importantes desaf√≠os debido a los costos de c√≥mputo. Estos costos se relacionan con el gasto monetario, los recursos computacionales requeridos, el tiempo de procesamiento, el uso de memoria, el almacenamiento y el consumo energ√©tico. A continuaci√≥n se presentan algunas de las implicaciones m√°s relevantes:\n\nInfraestructura: Manipular grandes vol√∫menes de datos requiere una infraestructura robusta, que incluye servidores potentes, almacenamiento masivo y redes de alta velocidad. Esto representa costos elevados en hardware, mantenimiento y consumo energ√©tico (Armbrust et al., 2010).\nEnerg√≠a: Los centros de datos que procesan grandes cantidades de informaci√≥n consumen enormes cantidades de energ√≠a, lo cual incrementa los costos operativos y contribuye al impacto ambiental debido a las emisiones de carbono (Baliga et al., 2011).\nAlmacenamiento: El almacenamiento de grandes vol√∫menes de datos requiere soluciones escalables y eficientes. Este aspecto representa un costo considerable, ya que tambi√©n debe garantizarse la recuperaci√≥n oportuna de la informaci√≥n.\nProcesamiento: Procesar datos en tiempo real o en tiempo cercano al real implica el uso de algoritmos eficientes y de recursos de c√≥mputo significativos. Estos costos pueden incrementarse especialmente al utilizar tecnolog√≠as como el aprendizaje autom√°tico y la inteligencia artificial (Wang et al., 2015).\n\nEn conjunto, la gesti√≥n de grandes vol√∫menes de informaci√≥n conlleva costos considerables en t√©rminos de infraestructura, energ√≠a, almacenamiento, procesamiento, seguridad y mantenimiento. Estos aspectos deben ser cuidadosamente planeados y gestionados para asegurar soluciones de big data eficientes y sostenibles."
  },
  {
    "objectID": "project1.html#conclusiones",
    "href": "project1.html#conclusiones",
    "title": "Proyecto 1",
    "section": "",
    "text": "En las simulaciones realizadas se observ√≥ que los √≥rdenes de crecimiento m√°s bajos, como O(1), O(log n) y O(n), resultan altamente eficientes. Son ideales para tareas que demandan rendimiento √≥ptimo y tiempos de respuesta reducidos.\nPor otro lado, los √≥rdenes de crecimiento O(n log n) y O(n¬≤) demostraron ser pr√°cticas y ampliamente aplicables, al ofrecer un buen equilibrio entre eficiencia y capacidad de procesamiento.\nEn contraste, las funciones con √≥rdenes de crecimiento elevados como O(2‚Åø), O(n!) y O(n‚Åø) resultaron ineficientes, generando tiempos de ejecuci√≥n excesivos o incluso errores de memoria.\nLa tabla de tiempos de ejecuci√≥n simulados confirma c√≥mo el crecimiento del orden afecta directamente el rendimiento de los algoritmos. A mayor orden, mayor consumo de recursos y tiempo; a menor orden, mayor eficiencia en la ejecuci√≥n."
  },
  {
    "objectID": "project1.html#referencias",
    "href": "project1.html#referencias",
    "title": "Proyecto 1",
    "section": "",
    "text": "M√ºller, V. C., Schal, J. M., Meyer-Lindenberg, A. (2016). Machine Learning for Brain Imaging. Cambridge University Press.\nManyika, J., Chui, M., Brown, B., Bughin, J., Dobbs, R., Roxburgh, C., & Byers, A. H. (2011). Big data: The next frontier for innovation, competition, and productivity. McKinsey Global Institute. https://www.mckinsey.com/business-functions/mckinsey-analytics/our-insights/big-data-the-next-frontier-for-innovation\nArmbrust, M., Fox, A., Griffith, R., Joseph, A. D., Katz, R. H., Konwinski, A., et al.¬†(2010). A View of Cloud Computing. Communications of the ACM, 53(4), 50‚Äì58. https://doi.org/10.1145/1721654.1721672\nBaliga, J., Ayre, R., Hinton, K., & Tucker, R. S. (2011). Energy-Efficient Telecommunications.\nWang, L., Chen, Y., & Liu, Q. (2015). Big Data Processing: A Survey. Springer."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre M√≠",
    "section": "",
    "text": "üìç Aguascalientes, M√©xico\n‚úâÔ∏è juan2javm@gmail.com / jvelasquez1800@alumno.ipn.mx\nüì± +52 322 353 4081\nüîó GitHub: juan21javm\nüîó LinkedIn: antonio-mart√≠nez-776788179\n\n\n\nMe considero una persona profundamente comprometida con el crecimiento intelectual, la lectura reflexiva y el bienestar de mi entorno cercano. Disfruto de los momentos al aire libre, donde encuentro inspiraci√≥n en la naturaleza y la tranquilidad necesaria para mantener un equilibrio emocional. Valoro profundamente el tiempo con mi familia, ya que es el motor que impulsa mi disciplina, responsabilidad y deseo de superaci√≥n constante. Asimismo, tengo una gran pasi√≥n por la programaci√≥n y un genuino entusiasmo por la ciencia de datos, √°reas que me permiten combinar creatividad, l√≥gica y an√°lisis riguroso para resolver problemas del mundo real. Estos principios personales complementan mi formaci√≥n acad√©mica y profesional, motiv√°ndome a mantener siempre una actitud proactiva, √©tica y humana.\n\n\n\n\nSupervisor ‚Äî INE (2023‚Äì2025), Loreto, Zacatecas\n- Supervisi√≥n de actividades diarias para cumplimiento de objetivos.\n- Capacitaci√≥n del equipo y mejora de rendimiento.\n- Evaluaci√≥n de desempe√±o y optimizaci√≥n de procesos.\nMaestro Asistente ‚Äî IPN (2022‚Äì2023), Zacatecas\n- Evaluaci√≥n del progreso estudiantil.\n- Planeaci√≥n conjunta de actividades educativas.\n- Creaci√≥n y adaptaci√≥n de materiales educativos.\n\n\n\n\nProyecto A ‚Äî Estandarizaci√≥n de proceso a nivel laboratorio (2021‚Äì2023)\n- Herramientas: MATLAB, HACCP Software, Latex\n- Liderazgo de investigaci√≥n para producci√≥n de yogurt con uvas a nivel laboratorio.\n- Reconocimiento al mejor promedio del programa acad√©mico (IPN 2017‚Äì2022).\n- Primer lugar en Simposium Agroalimentario y Ciclo de Conferencias CUALTIA 2023.\n\n\n\n\n\nLenguajes: Python, JAVA, HTML, ASPEN\n\nHerramientas Matem√°ticas: MATLAB, R, SPSS, PLC\n\nOfim√°tica: Office, LaTeX\n\n\n\n\n\n\nIdiomas: Espa√±ol (nativo), Ingl√©s (B1)\n\nIntereses: Lectura, b√∫squeda, planeaci√≥n"
  },
  {
    "objectID": "about.html#perfil-personal",
    "href": "about.html#perfil-personal",
    "title": "Sobre M√≠",
    "section": "",
    "text": "Me considero una persona profundamente comprometida con el crecimiento intelectual, la lectura reflexiva y el bienestar de mi entorno cercano. Disfruto de los momentos al aire libre, donde encuentro inspiraci√≥n en la naturaleza y la tranquilidad necesaria para mantener un equilibrio emocional. Valoro profundamente el tiempo con mi familia, ya que es el motor que impulsa mi disciplina, responsabilidad y deseo de superaci√≥n constante. Asimismo, tengo una gran pasi√≥n por la programaci√≥n y un genuino entusiasmo por la ciencia de datos, √°reas que me permiten combinar creatividad, l√≥gica y an√°lisis riguroso para resolver problemas del mundo real. Estos principios personales complementan mi formaci√≥n acad√©mica y profesional, motiv√°ndome a mantener siempre una actitud proactiva, √©tica y humana."
  },
  {
    "objectID": "about.html#experiencia",
    "href": "about.html#experiencia",
    "title": "Sobre M√≠",
    "section": "",
    "text": "Supervisor ‚Äî INE (2023‚Äì2025), Loreto, Zacatecas\n- Supervisi√≥n de actividades diarias para cumplimiento de objetivos.\n- Capacitaci√≥n del equipo y mejora de rendimiento.\n- Evaluaci√≥n de desempe√±o y optimizaci√≥n de procesos.\nMaestro Asistente ‚Äî IPN (2022‚Äì2023), Zacatecas\n- Evaluaci√≥n del progreso estudiantil.\n- Planeaci√≥n conjunta de actividades educativas.\n- Creaci√≥n y adaptaci√≥n de materiales educativos."
  },
  {
    "objectID": "about.html#proyectos-conferencias-y-reconocimientos",
    "href": "about.html#proyectos-conferencias-y-reconocimientos",
    "title": "Sobre M√≠",
    "section": "",
    "text": "Proyecto A ‚Äî Estandarizaci√≥n de proceso a nivel laboratorio (2021‚Äì2023)\n- Herramientas: MATLAB, HACCP Software, Latex\n- Liderazgo de investigaci√≥n para producci√≥n de yogurt con uvas a nivel laboratorio.\n- Reconocimiento al mejor promedio del programa acad√©mico (IPN 2017‚Äì2022).\n- Primer lugar en Simposium Agroalimentario y Ciclo de Conferencias CUALTIA 2023."
  },
  {
    "objectID": "about.html#habilidades",
    "href": "about.html#habilidades",
    "title": "Sobre M√≠",
    "section": "",
    "text": "Lenguajes: Python, JAVA, HTML, ASPEN\n\nHerramientas Matem√°ticas: MATLAB, R, SPSS, PLC\n\nOfim√°tica: Office, LaTeX"
  },
  {
    "objectID": "about.html#informaci√≥n-adicional",
    "href": "about.html#informaci√≥n-adicional",
    "title": "Sobre M√≠",
    "section": "",
    "text": "Idiomas: Espa√±ol (nativo), Ingl√©s (B1)\n\nIntereses: Lectura, b√∫squeda, planeaci√≥n"
  },
  {
    "objectID": "index.html#presentaci√≥n-del-proyecto",
    "href": "index.html#presentaci√≥n-del-proyecto",
    "title": "Centro de Investigaci√≥n e Innovaci√≥n en Tecnolog√≠as de la Informaci√≥n y Comunicaci√≥n",
    "section": "Presentaci√≥n del proyecto",
    "text": "Presentaci√≥n del proyecto\nEn esta p√°gina se encuentran reflejados los cinco reportes desarrollados a lo largo de la asignatura de An√°lisis de Algoritmos. Cada uno de ellos ha sido debidamente documentado, estructurado y trasladado al formato Quarto con el prop√≥sito de comunicar al p√∫blico el trabajo realizado y los an√°lisis efectuados durante mi estancia en la materia. Estos reportes representan el proceso de aprendizaje y aplicaci√≥n pr√°ctica de los conceptos clave abordados en cada unidad, desde la introducci√≥n al an√°lisis algor√≠tmico hasta los algoritmos de intersecci√≥n de conjuntos, permitiendo evidenciar el desarrollo de competencias t√©cnicas y anal√≠ticas fundamentales en el √°rea.\nEsta documentaci√≥n ha sido preparada para su publicaci√≥n en un repositorio de GitHub con el objetivo de compartir de forma abierta los contenidos desarrollados, promover el acceso al conocimiento, y facilitar su consulta por parte de docentes, estudiantes y profesionales interesados en el an√°lisis de algoritmos.\nA lo largo del curso se desarrollaron cinco tareas escritas que reflejan los temas fundamentales abordados en cada unidad:\n\nUnidad 1: Introducci√≥n al an√°lisis de algoritmos\nSe realiz√≥ el reporte 1A. Reporte escrito. Experimentos y an√°lisis, en el que se exploraron conceptos b√°sicos sobre la eficiencia algor√≠tmica y √≥rdenes de crecimiento.\nUnidad 2: Estructuras de datos\nSe trabaj√≥ el reporte 2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos, enfocado en el comportamiento, manipulaci√≥n y an√°lisis de distintas estructuras como listas, pilas, colas y √°rboles.\nUnidad 3: Algoritmos de ordenamiento por comparaci√≥n\nSe elabor√≥ el 3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento, donde se evaluaron m√©todos como burbuja, inserci√≥n, selecci√≥n, quicksort y mergesort.\nUnidad 4: Algoritmos de b√∫squeda por comparaci√≥n\nSe desarroll√≥ el reporte 4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n, abordando t√©cnicas como la b√∫squeda lineal y binaria, con un enfoque en su eficiencia.\nUnidad 5: Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n\nSe present√≥ el 5A. Reporte escrito. Experimentos y an√°lisis de algoritmos de intersecci√≥n de conjuntos, donde se analizaron distintas estrategias para operar sobre m√∫ltiples listas ordenadas."
  },
  {
    "objectID": "project2.html",
    "href": "project2.html",
    "title": "Proyecto 2",
    "section": "",
    "text": "Proyecto 2\nDescripci√≥n del Proyecto 2. Informaci√≥n relevante sobre este segundo proyecto."
  }
]